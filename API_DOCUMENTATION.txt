Sec Messenger Backend - API Documentation
=========================================

Base URL
--------
- Local API: http://127.0.0.1:5000
- Production API: https://api.dinosocial.ir
- Frontend/Web: https://dinosocial.ir (not API origin)
- Production media URLs are generated from `APP_PUBLIC_BASE_URL`.

Authentication
--------------
- Auth type: JWT Bearer token.
- Include for protected endpoints:
  Authorization: Bearer <access_token>
- Access token is returned by POST /api/auth/login and POST /api/auth/refresh.

Live Test Account (created February 25, 2026)
---------------------------------------------
- Base URL: https://api.dinosocial.ir
- Username: codex_verify_20260225191422
- Password: CodexPost!2026
- Refresh token:
  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc3MjAzNDI2NywianRpIjoiMjljZWQwMDEtN2YzZC00MjYxLWEyY2YtNTUzOTVkZTM1NDUzIiwidHlwZSI6InJlZnJlc2giLCJzdWIiOiJjb2RleF92ZXJpZnlfMjAyNjAyMjUxOTE0MjIiLCJuYmYiOjE3NzIwMzQyNjcsImNzcmYiOiJlZWUwNmNlNi1mNzhlLTQ5YTMtOTUzNi1hYWJjMjFlZjhhNWMiLCJleHAiOjE3NzQ2MjYyNjd9.Ahlw8GK4clZUmF_nQybKaFouhPWCJsS91XpM-Olk6PQ
- Note: rotate/remove this credential after testing (refresh tokens should not stay in docs long-term).

Common Error Format
-------------------
- Most errors return:
  {"error": "message"}

HTTP API
========

1) Main
-------
GET /
- Description: Render backend index page.
- Auth: No
- Response: HTML page (app/templates/index.html)

GET /media/{object_name}
- Description: Stream a media object from configured storage bucket.
- Auth: No
- Methods: GET, HEAD
- Success:
  - 200 binary stream (image/video) for GET
  - 200 headers-only for HEAD
  - 304 when browser/CDN cache is valid (If-None-Match / If-Modified-Since)
- Response headers (important for performance):
  - Cache-Control: `public, max-age=<MEDIA_CACHE_MAX_AGE_SECONDS>[, immutable]`
  - ETag
  - Last-Modified
  - Accept-Ranges: bytes
- Errors:
  404 {"error": "Media not found"}
  503 {"error": "Media unavailable"}


2) Auth
-------
POST /api/auth/register
- Description: Register a new user.
- Auth: No
- Content-Type: application/json
- Request JSON:
  {
    "username": "alice",
    "password": "pass123",
    "public_key": "-----BEGIN PUBLIC KEY-----...",
    "name": "Alice"
  }
- Notes:
  - `name` is optional. If omitted, it defaults to `username`.
- Success: 201
  {"message": "User registered"}
- Errors: 400
  {"error": "Missing fields"}
  {"error": "Name must be a non-empty string"}
  {"error": "Username already exists"}

POST /api/auth/login
- Description: Login user and return tokens.
- Auth: No
- Content-Type: application/json
- Request JSON:
  {
    "username": "alice",
    "password": "pass123"
  }
- Success: 200
  {
    "access_token": "<jwt>",
    "refresh_token": "<jwt>"
  }
- Errors: 401
  {"error": "Invalid credentials"}

Refresh Token
- Purpose: Used to get a new access token after the access token expires.
- Issued by: POST /api/auth/login (`refresh_token` field in response).
- Endpoint (implemented):
  POST /api/auth/refresh
- Alias (implemented for compatibility):
  POST /api/auth/token
- Auth:
  - Send refresh token in Authorization header:
    Authorization: Bearer <refresh_token>
- Request Body:
  - None required.
- Success: 200
  {
    "access_token": "<jwt>"
  }
- Errors:
  401 missing/expired/invalid token
  422 wrong token type (for example, access token sent instead of refresh token)


3) Contacts (Compatibility Layer)
---------------------------------
POST /api/contacts
- Description: Legacy endpoint. Internally maps to follow behavior.
- Auth: Yes
- Content-Type: application/json
- Request JSON:
  {
    "contact": "bob"
  }
- Success: 200
  {"message": "Contact added"}
- Errors:
  400 {"error": "Invalid JSON body"}
  {"error": "Contact not found"}
  {"error": "You cannot follow yourself"}

GET /api/contacts
- Description: Legacy endpoint. Returns usernames the requester is following.
- Auth: Yes
- Success: 200
  {
    "contacts": ["bob", "charlie"]
  }

GET /api/contacts/{username}/public-key
- Description: Get public key only if requester follows target user.
- Auth: Yes
- Success: 200
  {"public_key": "-----BEGIN PUBLIC KEY-----..."}
- Errors:
  404 {"error": "User not found"}
  403 {"error": "Not in your contacts"}


4) Profiles
-----------
GET /api/profiles/me
- Description: Get current authenticated user's profile.
- Auth: Yes
- Success: 200
  {
    "username": "alice",
    "name": "Alice",
    "bio": "Hello there",
    "profile_image_url": "https://api.dinosocial.ir/media/profiles/1/uuid.jpeg",
    "followers_count": 10,
    "following_count": 5,
    "posts_count": 12
  }
- Errors:
  401 JWT auth error (missing/invalid/expired token)

PUT /api/profiles/me
- Description: Update current user's profile fields and optionally upload profile image.
- Auth: Yes
- Content-Type:
  - application/json (for text fields)
  - multipart/form-data (for text fields + file upload)
- Request JSON example:
  {
    "name": "Alice Cooper",
    "bio": "Building DinoSocial"
  }
- Request multipart fields:
  - name: optional string
  - bio: optional string
  - profile_image or avatar: optional file (image/jpeg, image/png, image/webp)
- Success: 200
  {
    "username": "alice",
    "name": "Alice Cooper",
    "bio": "Building DinoSocial",
    "profile_image_url": "https://api.dinosocial.ir/media/profiles/1/uuid.jpeg",
    "followers_count": 10,
    "following_count": 5,
    "posts_count": 12
  }
- Errors:
  400 {"error": "Invalid JSON body"}
  400 {"error": "At least one field is required"}
  400 {"error": "Name must be a non-empty string"}
  400 {"error": "Bio must be a string"}
  400 {"error": "Profile image file is required"}
  400 {"error": "Unsupported media type: ..."}
  401 JWT auth error (missing/invalid/expired token)

GET /api/profiles/{username}
- Description: Get a user's public profile by username.
- Auth: No
- Success: 200
  {
    "username": "bob",
    "name": "Bob",
    "bio": "",
    "profile_image_url": null,
    "followers_count": 3,
    "following_count": 7,
    "posts_count": 2
  }
- Errors:
  404 {"error": "User not found"}

GET /api/profiles/{username}/posts
- Description: List posts published by specific user (paginated).
- Auth: No
- Query Params:
  page (int, default: 1)
  limit (int, default: 10, max effective value: 50)
- Success: 200
  {
    "page": 1,
    "limit": 10,
    "total": 2,
    "posts": [
      {
        "id": 10,
        "text": "My post",
        "author": {
          "id": 2,
          "username": "bob",
          "name": "Bob",
          "profile_image_url": null
        },
        "created_at": "2026-02-12T10:00:00.000000",
        "media": []
      }
    ]
  }
- Errors:
  404 {"error": "User not found"}


5) Follows
----------
POST /api/follows/{username}
- Description: Follow a user by username.
- Auth: Yes
- Success: 200
  {"message": "Followed"}
  {"message": "Already following"}
- Errors:
  404 {"error": "User not found"}
  400 {"error": "You cannot follow yourself"}
  401 JWT auth error (missing/invalid/expired token)

DELETE /api/follows/{username}
- Description: Unfollow a user by username.
- Auth: Yes
- Success: 200
  {"message": "Unfollowed"}
  {"message": "Not following"}
- Errors:
  404 {"error": "User not found"}
  400 {"error": "You cannot unfollow yourself"}
  401 JWT auth error (missing/invalid/expired token)


6) Messages (HTTP)
------------------
POST /api/messages/send
- Description: Deprecated for sending.
- Auth: Yes
- Response: 410
  {"error": "HTTP send is deprecated. Use socket event 'send_message'."}

GET /api/messages/inbox
- Description: Pop and return queued inbox messages for current user.
- Auth: Yes
- Success: 200
  {
    "messages": [
      {
        "from": "alice",
        "message": "<encrypted_message>",
        "encrypted_key": "<encrypted_key>",
        "timestamp": "2026-02-12T12:34:56.123456"
      }
    ]
  }


7) Posts
--------
POST /api/posts
- Description: Create a new post for the authenticated user (text with optional media).
- Auth: Yes
- Content-Type:
  - application/json (text-only)
  - multipart/form-data (text + optional media upload)
- Request JSON:
  {
    "text": "Hello world"
  }
- Request multipart fields:
  - text: required string
  - media / media[] / files / file: optional file(s), max 8 total
- Request Field Rules:
  - text: required string
  - Empty or whitespace-only values are rejected.
  - Text is trimmed before storing.
  - Max 8 media files per post.
  - Supported image types: image/jpeg, image/png, image/webp
  - Supported video types: video/mp4, video/quicktime
  - Videos must be 30 minutes (1800s) or shorter.
  - If MinIO/object-storage is unavailable and `MEDIA_LOCAL_FALLBACK_ENABLED=true`, media is stored under `/static/uploads/posts/...`.
- Success: 201
  {
    "message": "Post created successfully",
    "post_id": 1
  }
- Errors:
  400 {"error": "Invalid JSON body"}
  400 {"error": "Text is required"}
  400 {"error": "Maximum 8 media files allowed"}
  400 {"error": "Unsupported media type: ..."}
  400 {"error": "Could not determine video duration"}
  400 {"error": "Video must be 30 minutes or shorter"}
  400 {"error": "User not found"}
  503 {"error": "Media storage is unavailable"} (when fallback is disabled or local fallback also fails)
  401 JWT auth error (missing/invalid/expired token)

GET /api/posts
- Description: List posts (paginated).
- Auth: No (currently public)
- Query Params:
  page (int, default: 1)
  limit (int, default: 10, max effective value: 50)
- Behavior:
  - If limit > 50, response limit is capped to 50.
- Success: 200
  {
    "page": 1,
    "limit": 10,
    "total": 5,
    "posts": [
      {
        "id": 1,
        "text": "Hello",
        "author": {
          "id": 1,
          "username": "alice",
          "name": "Alice",
          "profile_image_url": "https://api.dinosocial.ir/media/profiles/1/uuid.jpeg"
        },
        "created_at": "2026-02-12T10:00:00.000000",
        "media": [
          {
            "id": 1,
            "url": "https://api.dinosocial.ir/media/posts/1/uuid.jpeg",
            "mime_type": "image/jpeg"
          }
        ]
      }
    ]
  }
- Notes:
  - `author` is an object with `id`, `username`, `name`, and `profile_image_url`.
  - `author.profile_image_url` is `null` when the author has no profile image.
  - `media.url` points to backend media route (`GET /media/{object_name}`), not localhost MinIO.
  - If local media fallback is enabled and used, URL can be `/static/uploads/...`.


8) Comments
-----------
POST /api/posts/{post_id}/comments
- Description: Create a comment for a post (supports replies via `parent_id`).
- Auth: Yes
- Content-Type: application/json
- Request JSON:
  {
    "text": "Nice post",
    "parent_id": null
  }
- Request Field Rules:
  - text: required string
  - Empty or whitespace-only values are rejected.
  - parent_id: optional integer. If provided, it must reference an existing comment on the same post.
- Success: 201
  {
    "id": 12,
    "message": "Comment created"
  }
- Errors:
  404 {"error": "User not found"}
  400 {"error": "Comment text is required"}
  400 {"error": "Post not found"}
  400 {"error": "Invalid parent comment"}
  401 JWT auth error (missing/invalid/expired token)

GET /api/posts/{post_id}/comments
- Description: Fetch a paginated tree of comments for a post.
- Auth: No
- Query Params:
  page (int, default: 1)
  page_size (int, default: 10)
- Success: 200
  [
    {
      "id": 12,
      "author": {
        "id": 1,
        "username": "alice",
        "name": "Alice",
        "profile_image_url": "https://api.dinosocial.ir/media/profiles/1/uuid.jpeg"
      },
      "text": "Root comment",
      "score": 3,
      "created_at": "Wed, 12 Feb 2026 12:34:56 GMT",
      "parent_id": null,
      "replies": [
        {
          "id": 13,
          "author": {
            "id": 2,
            "username": "bob",
            "name": "Bob",
            "profile_image_url": null
          },
          "text": "Reply comment",
          "score": 1,
          "created_at": "Wed, 12 Feb 2026 12:40:00 GMT",
          "parent_id": 12,
          "replies": []
        }
      ]
    }
  ]
- Notes:
  - Response contains only root comments for the requested page; each root includes its nested replies.
  - Comments are ordered by score (desc), then creation time (newer first).


9) Votes
--------
POST /api/votes
- Description: Create or update the current user's vote on a post/comment.
- Auth: Yes
- Content-Type: application/json
- Request JSON:
  {
    "target_type": "post",
    "target_id": 1,
    "value": 1
  }
- Request Field Rules:
  - target_type: required string, allowed values: `post`, `comment`
  - target_id: required integer
  - value: required integer, allowed values: `1` (upvote) or `-1` (downvote)
- Success: 200
  {"message": "Vote recorded"}
- Errors:
  400 {"error": "Invalid target type"}
  400 {"error": "Invalid vote value"}
  400 {"error": "User not found"}
  401 JWT auth error (missing/invalid/expired token)
- Notes:
  - Voting is idempotent per user+target. Sending the same vote value again keeps state unchanged and still returns 200.
  - If a previous vote exists with a different value, it is updated (upsert behavior) instead of creating a duplicate vote.
  - Current implementation does not return a 404 when `target_id` does not exist.


Socket API (Messaging)
======================

Transport
---------
- Socket.IO server mounted on default namespace: /
- Development run command uses `socketio.run(app, debug=True)`.

Socket Authentication
---------------------
- Required at connection time.
- Any one of these is accepted:
  1) `auth` payload: {"token": "<access_token>"} (recommended)
  2) Authorization header: Bearer <access_token>
  3) Query param: ?token=<access_token>
- If token missing/invalid, connection is rejected.

Connection Behavior
-------------------
Event emitted by server on successful connect:
- `connected`
  {
    "username": "alice"
  }

If queued messages exist, server also emits:
- `pending_messages`
  {
    "messages": [
      {
        "from": "bob",
        "message": "<encrypted_message>",
        "encrypted_key": "<encrypted_key>",
        "timestamp": "2026-02-12T12:34:56.123456"
      }
    ]
  }

Send Message Event
------------------
Client emit:
- `send_message`
  {
    "to": "bob",
    "message": "<encrypted_message>",
    "encrypted_key": "<encrypted_key>"
  }

Server emits to sender on success:
- `message_sent`
  {
    "to": "bob",
    "timestamp": "2026-02-12T12:34:56.123456"
  }

Server emits to recipient:
- `new_message`
  {
    "from": "alice",
    "message": "<encrypted_message>",
    "encrypted_key": "<encrypted_key>",
    "timestamp": "2026-02-12T12:34:56.123456"
  }

Server emits to sender on validation/auth errors:
- `message_error`
  {"error": "Recipient not found"}
  {"error": "Message is required"}
  {"error": "Encrypted key is required"}
  {"error": "Unauthorized"}
  {"error": "Invalid payload"}

Delivery Rules
--------------
- If recipient is online: message is delivered live (`new_message`) and not queued.
- If recipient is offline: message is queued in Redis and delivered as `pending_messages` next time recipient connects.


Test Coverage Added
===================
- File: tests/test_message_socket.py
- Covered scenarios:
  1) Online recipient receives `new_message` immediately.
  2) Offline recipient receives `pending_messages` after connecting.
