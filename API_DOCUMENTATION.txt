Sec Messenger Backend - API Documentation
=========================================

Base URL
--------
- Local: http://127.0.0.1:5000

Authentication
--------------
- Auth type: JWT Bearer token.
- Include for protected endpoints:
  Authorization: Bearer <access_token>
- Access token is returned by POST /api/auth/login.

Common Error Format
-------------------
- Most errors return:
  {"error": "message"}

HTTP API
========

1) Main
-------
GET /
- Description: Render backend index page.
- Auth: No
- Response: HTML page (app/templates/index.html)


2) Auth
-------
POST /api/auth/register
- Description: Register a new user.
- Auth: No
- Request JSON:
  {
    "username": "alice",
    "password": "pass123",
    "public_key": "-----BEGIN PUBLIC KEY-----..."
  }
- Success: 201
  {"message": "User registered"}
- Errors: 400
  {"error": "Missing fields"}
  {"error": "Username already exists"}

POST /api/auth/login
- Description: Login user and return tokens.
- Auth: No
- Request JSON:
  {
    "username": "alice",
    "password": "pass123"
  }
- Success: 200
  {
    "access_token": "<jwt>",
    "refresh_token": "<jwt>"
  }
- Errors: 401
  {"error": "Invalid credentials"}


3) Contacts
-----------
POST /api/contacts
- Description: Add contact to current user's contact list.
- Auth: Yes
- Request JSON:
  {
    "contact": "bob"
  }
- Success: 200
  {"message": "Contact added"}
- Errors: 400
  {"error": "Contact not found"}

GET /api/contacts
- Description: List current user's contacts.
- Auth: Yes
- Success: 200
  {
    "contacts": ["bob", "charlie"]
  }

GET /api/contacts/{username}/public-key
- Description: Get public key for a contact only if user is already in requester's contact list.
- Auth: Yes
- Success: 200
  {"public_key": "-----BEGIN PUBLIC KEY-----..."}
- Errors:
  404 {"error": "User not found"}
  403 {"error": "Not in your contacts"}


4) Messages (HTTP)
------------------
POST /api/messages/send
- Description: Deprecated for sending.
- Auth: Yes
- Response: 410
  {"error": "HTTP send is deprecated. Use socket event 'send_message'."}

GET /api/messages/inbox
- Description: Pop and return queued inbox messages for current user.
- Auth: Yes
- Success: 200
  {
    "messages": [
      {
        "from": "alice",
        "message": "<encrypted_message>",
        "encrypted_key": "<encrypted_key>",
        "timestamp": "2026-02-12T12:34:56.123456"
      }
    ]
  }


5) Posts
--------
POST /api/posts
- Description: Create text post (JSON only, no media upload in current route).
- Auth: Yes
- Request JSON:
  {
    "text": "Hello world"
  }
- Success: 201
  {
    "message": "Post created successfully",
    "post_id": 1
  }
- Errors:
  400 {"error": "Invalid JSON body"}
  400 {"error": "Text is required"}

GET /api/posts
- Description: List posts (paginated).
- Auth: No (currently public)
- Query Params:
  page (default: 1)
  limit (default: 10, max: 50)
- Success: 200
  {
    "page": 1,
    "limit": 10,
    "total": 5,
    "posts": [
      {
        "id": 1,
        "text": "Hello",
        "author": 1,
        "created_at": "2026-02-12T10:00:00.000000",
        "media": [
          {
            "id": 1,
            "url": "http://127.0.0.1:9000/media/posts/1/uuid.jpeg",
            "mime_type": "image/jpeg"
          }
        ]
      }
    ]
  }


6) Comments
-----------
POST /api/posts/{post_id}/comments
- Description: Create comment on post (supports reply via parent_id).
- Auth: Yes
- Request JSON:
  {
    "text": "Nice post",
    "parent_id": null
  }
- Success: 201
  {
    "id": 12,
    "message": "Comment created"
  }
- Errors:
  404 {"error": "User not found"}
  400 {"error": "Comment text is required"}

GET /api/posts/{post_id}/comments
- Description: Fetch comments tree for a post.
- Auth: No
- Response: 200 JSON list/tree of comments.

Important note:
- The code currently defines GET /api/posts/{post_id}/comments twice in `app/routes/comment_routes.py`.
- This is a routing conflict and should be consolidated to one handler.


7) Votes
--------
POST /api/votes
- Description: Vote on post/comment.
- Auth: Yes
- Request JSON:
  {
    "target_type": "post",
    "target_id": 1,
    "value": 1
  }
- Success: 200
  {"message": "Vote recorded"}
- Errors:
  400 {"error": "Invalid target type"}
  400 {"error": "Invalid vote value"}
  400 {"error": "User not found"}


Socket API (Messaging)
======================

Transport
---------
- Socket.IO server mounted on default namespace: /
- Development run command uses `socketio.run(app, debug=True)`.

Socket Authentication
---------------------
- Required at connection time.
- Any one of these is accepted:
  1) `auth` payload: {"token": "<access_token>"} (recommended)
  2) Authorization header: Bearer <access_token>
  3) Query param: ?token=<access_token>
- If token missing/invalid, connection is rejected.

Connection Behavior
-------------------
Event emitted by server on successful connect:
- `connected`
  {
    "username": "alice"
  }

If queued messages exist, server also emits:
- `pending_messages`
  {
    "messages": [
      {
        "from": "bob",
        "message": "<encrypted_message>",
        "encrypted_key": "<encrypted_key>",
        "timestamp": "2026-02-12T12:34:56.123456"
      }
    ]
  }

Send Message Event
------------------
Client emit:
- `send_message`
  {
    "to": "bob",
    "message": "<encrypted_message>",
    "encrypted_key": "<encrypted_key>"
  }

Server emits to sender on success:
- `message_sent`
  {
    "to": "bob",
    "timestamp": "2026-02-12T12:34:56.123456"
  }

Server emits to recipient:
- `new_message`
  {
    "from": "alice",
    "message": "<encrypted_message>",
    "encrypted_key": "<encrypted_key>",
    "timestamp": "2026-02-12T12:34:56.123456"
  }

Server emits to sender on validation/auth errors:
- `message_error`
  {"error": "Recipient not found"}
  {"error": "Message is required"}
  {"error": "Encrypted key is required"}
  {"error": "Unauthorized"}
  {"error": "Invalid payload"}

Delivery Rules
--------------
- If recipient is online: message is delivered live (`new_message`) and not queued.
- If recipient is offline: message is queued in Redis and delivered as `pending_messages` next time recipient connects.


Test Coverage Added
===================
- File: tests/test_message_socket.py
- Covered scenarios:
  1) Online recipient receives `new_message` immediately.
  2) Offline recipient receives `pending_messages` after connecting.

